// src/commands.ts
import logger3 from "@wdio/logger";

// src/constants.ts
import InstallableManifest from "lighthouse/lighthouse-core/audits/installable-manifest.js";
import ServiceWorker from "lighthouse/lighthouse-core/audits/service-worker.js";
import SplashScreen from "lighthouse/lighthouse-core/audits/splash-screen.js";
import ThemedOmnibox from "lighthouse/lighthouse-core/audits/themed-omnibox.js";
import ContentWidth from "lighthouse/lighthouse-core/audits/content-width.js";
import Viewport from "lighthouse/lighthouse-core/audits/viewport.js";
import AppleTouchIcon from "lighthouse/lighthouse-core/audits/apple-touch-icon.js";
import MaskableIcon from "lighthouse/lighthouse-core/audits/maskable-icon.js";
import { throttling } from "lighthouse/lighthouse-core/config/constants.js";
var DEFAULT_TRACING_CATEGORIES = [
  // Exclude default categories. We'll be selective to minimize trace size
  "-*",
  // Used instead of 'toplevel' in Chrome 71+
  "disabled-by-default-lighthouse",
  // Used for Cumulative Layout Shift metric
  "loading",
  // All compile/execute events are captured by parent events in devtools.timeline..
  // But the v8 category provides some nice context for only <0.5% of the trace size
  "v8",
  // Same situation here. This category is there for RunMicrotasks only, but with other teams
  // accidentally excluding microtasks, we don't want to assume a parent event will always exist
  "v8.execute",
  // For extracting UserTiming marks/measures
  "blink.user_timing",
  // Not mandatory but not used much
  "blink.console",
  // Most of the events we need are from these two categories
  "devtools.timeline",
  "disabled-by-default-devtools.timeline",
  // Up to 450 (https://goo.gl/rBfhn4) JPGs added to the trace
  "disabled-by-default-devtools.screenshot",
  // This doesn't add its own events, but adds a `stackTrace` property to devtools.timeline events
  "disabled-by-default-devtools.timeline.stack",
  // Additional categories used by devtools. Not used by Lighthouse, but included to facilitate
  // loading traces from Lighthouse into the Performance panel.
  "disabled-by-default-devtools.timeline.frame",
  "latencyInfo"
  // CPU sampling profiler data only enabled for debugging purposes
  // 'disabled-by-default-v8.cpu_profiler',
  // 'disabled-by-default-v8.cpu_profiler.hires',
];
var IGNORED_URLS = [
  "data:,",
  // empty pages
  "about:",
  // new tabs
  "chrome-extension://"
  // all chrome extensions
];
var FRAME_LOAD_START_TIMEOUT = 2e3;
var TRACING_TIMEOUT = 15e3;
var MAX_TRACE_WAIT_TIME = 45e3;
var DEFAULT_NETWORK_THROTTLING_STATE = "online";
var DEFAULT_FORM_FACTOR = "desktop";
var UNSUPPORTED_ERROR_MESSAGE = "Can't connect to Chrome DevTools! The @wdio/lighthouse-service currently only supports Chrome and Chromium!\n\nGiven that cloud vendors don't expose access to the Chrome DevTools Protocol this service also usually only works when running tests locally or through a Selenium Grid (https://www.selenium.dev/documentation/grid/) v4 or higher.";
var NETWORK_STATES = {
  offline: {
    offline: true,
    latency: 0,
    downloadThroughput: 0,
    uploadThroughput: 0
  },
  GPRS: {
    offline: false,
    downloadThroughput: 50 * 1024 / 8,
    uploadThroughput: 20 * 1024 / 8,
    latency: 500
  },
  "Regular 2G": {
    offline: false,
    downloadThroughput: 250 * 1024 / 8,
    uploadThroughput: 50 * 1024 / 8,
    latency: 300
  },
  "Good 2G": {
    offline: false,
    downloadThroughput: 450 * 1024 / 8,
    uploadThroughput: 150 * 1024 / 8,
    latency: 150
  },
  "Regular 3G": {
    offline: false,
    latency: throttling.mobileRegular3G.requestLatencyMs,
    // DevTools expects throughput in bytes per second rather than kbps
    downloadThroughput: Math.floor(throttling.mobileRegular3G.downloadThroughputKbps * 1024 / 8),
    uploadThroughput: Math.floor(throttling.mobileRegular3G.uploadThroughputKbps * 1024 / 8)
  },
  "Good 3G": {
    offline: false,
    latency: throttling.mobileSlow4G.requestLatencyMs,
    // DevTools expects throughput in bytes per second rather than kbps
    downloadThroughput: Math.floor(throttling.mobileSlow4G.downloadThroughputKbps * 1024 / 8),
    uploadThroughput: Math.floor(throttling.mobileSlow4G.uploadThroughputKbps * 1024 / 8)
  },
  "Regular 4G": {
    offline: false,
    downloadThroughput: 4 * 1024 * 1024 / 8,
    uploadThroughput: 3 * 1024 * 1024 / 8,
    latency: 20
  },
  "DSL": {
    offline: false,
    downloadThroughput: 2 * 1024 * 1024 / 8,
    uploadThroughput: 1 * 1024 * 1024 / 8,
    latency: 5
  },
  "Wifi": {
    offline: false,
    downloadThroughput: 30 * 1024 * 1024 / 8,
    uploadThroughput: 15 * 1024 * 1024 / 8,
    latency: 2
  },
  online: {
    offline: false,
    latency: 0,
    downloadThroughput: -1,
    uploadThroughput: -1
  }
};
var CLICK_TRANSITION = "click transition";
var DEFAULT_THROTTLE_STATE = {
  networkThrottling: DEFAULT_NETWORK_THROTTLING_STATE,
  cpuThrottling: 0,
  cacheEnabled: false,
  formFactor: DEFAULT_FORM_FACTOR
};
var NETWORK_RECORDER_EVENTS = [
  "Network.requestWillBeSent",
  "Network.requestServedFromCache",
  "Network.responseReceived",
  "Network.dataReceived",
  "Network.loadingFinished",
  "Network.loadingFailed",
  "Network.resourceChangedPriority"
];
var PWA_AUDITS = {
  isInstallable: InstallableManifest,
  serviceWorker: ServiceWorker,
  splashScreen: SplashScreen,
  themedOmnibox: ThemedOmnibox,
  contentWith: ContentWidth,
  viewport: Viewport,
  appleTouchIcon: AppleTouchIcon,
  maskableIcon: MaskableIcon
};

// src/handler/network.ts
var NetworkHandler = class {
  requestLog = { requests: [] };
  requestTypes = {};
  cachedFirstRequest;
  constructor(session) {
    session.on("Network.dataReceived", this.onDataReceived.bind(this));
    session.on("Network.responseReceived", this.onNetworkResponseReceived.bind(this));
    session.on("Network.requestWillBeSent", this.onNetworkRequestWillBeSent.bind(this));
    session.on("Page.frameNavigated", this.onPageFrameNavigated.bind(this));
  }
  findRequest(params) {
    let request = this.requestLog.requests.find((req) => req.id === params.requestId);
    if (!request && this.cachedFirstRequest && this.cachedFirstRequest.id === params.requestId) {
      request = this.cachedFirstRequest;
    }
    return request;
  }
  onDataReceived(params) {
    const request = this.findRequest(params);
    if (!request || !request.type || !this.requestTypes[request.type]) {
      return;
    }
    const type = request.type;
    const requestType = this.requestTypes[type] || {};
    requestType.size += params.dataLength;
    requestType.encoded += params.encodedDataLength;
  }
  onNetworkResponseReceived(params) {
    const request = this.findRequest(params);
    if (!request) {
      return;
    }
    request.statusCode = params.response.status;
    request.requestHeaders = params.response.requestHeaders;
    request.responseHeaders = params.response.headers;
    request.timing = params.response.timing;
    request.type = params.type;
  }
  onNetworkRequestWillBeSent(params) {
    let isFirstRequestOfFrame = false;
    if (
      /**
       * A new page was opened when request type is a document.
       * The first request is sent before the Page.frameNavigated event is triggered,
       * so this request must be cached to be able to add it to the requestLog later.
       */
      params.type === "Document" && /**
       * ensure that only page loads triggered by non scripts (devtools only) are considered
       * new page loads
       */
      params.initiator.type === "other" && /**
       * ignore pages not initated by the user
       */
      IGNORED_URLS.filter((url) => params.request.url.startsWith(url)).length === 0
    ) {
      isFirstRequestOfFrame = true;
      this.requestTypes = {};
    }
    const log4 = {
      id: params.requestId,
      url: params.request.url,
      method: params.request.method
    };
    if (params.redirectResponse) {
      log4.redirect = {
        url: params.redirectResponse.url,
        statusCode: params.redirectResponse.status,
        requestHeaders: params.redirectResponse.requestHeaders,
        responseHeaders: params.redirectResponse.headers,
        timing: params.redirectResponse.timing
      };
    }
    if (params.type) {
      const requestType = this.requestTypes[params.type];
      if (!requestType) {
        this.requestTypes[params.type] = {
          size: 0,
          encoded: 0,
          count: 1
        };
      } else if (requestType) {
        requestType.count++;
      }
    }
    if (isFirstRequestOfFrame) {
      log4.loaderId = params.loaderId;
      this.cachedFirstRequest = log4;
      return;
    }
    return this.requestLog.requests.push(log4);
  }
  onPageFrameNavigated(params) {
    if (!params.frame.parentId && IGNORED_URLS.filter((url) => params.frame.url.startsWith(url)).length === 0) {
      this.requestLog = {
        id: params.frame.loaderId,
        url: params.frame.url,
        requests: []
      };
      if (this.cachedFirstRequest && this.cachedFirstRequest.loaderId === params.frame.loaderId) {
        delete this.cachedFirstRequest.loaderId;
        this.requestLog.requests.push(this.cachedFirstRequest);
        this.cachedFirstRequest = void 0;
      }
    }
  }
};

// src/utils.ts
import Driver from "lighthouse/lighthouse-core/gather/driver.js";

// src/lighthouse/cri.ts
import CriConnection from "lighthouse/lighthouse-core/gather/connections/cri.js";
var DEFAULT_HOSTNAME = "localhost";
var DEFAULT_PORT = "9222";
var ChromeProtocolPatched = class extends CriConnection {
  _sessionId;
  /**
   * Add constructor for typing safety
   * @param {number=} port Optional port number. Defaults to 9222;
   * @param {string=} hostname Optional hostname. Defaults to localhost.
   * @constructor
   */
  constructor(port = DEFAULT_PORT, hostname = DEFAULT_HOSTNAME) {
    super(port, hostname);
  }
  setSessionId(sessionId) {
    this._sessionId = sessionId;
  }
  /**
   * force every command to be send with the given session id
   */
  sendCommand(method, sessionId, ...paramArgs) {
    return super.sendCommand(method, sessionId || this._sessionId, ...paramArgs);
  }
};

// src/utils.ts
var CUSTOM_COMMANDS = [
  "getMetrics",
  "startTracing",
  "getDiagnostics",
  "getCoverageReport",
  "enablePerformanceAudits",
  "disablePerformanceAudits",
  "getMainThreadWorkBreakdown",
  "checkPWA"
];
function setUnsupportedCommand(browser) {
  for (const command of CUSTOM_COMMANDS) {
    browser.addCommand(
      command,
      /* istanbul ignore next */
      () => {
        throw new Error(UNSUPPORTED_ERROR_MESSAGE);
      }
    );
  }
}
function sumByKey(list, key) {
  return list.map((data) => data[key]).reduce((acc, val) => acc + val, 0);
}
function isSupportedUrl(url) {
  return IGNORED_URLS.filter((ignoredUrl) => url.startsWith(ignoredUrl)).length === 0;
}
async function getLighthouseDriver(session, target) {
  const connection = session.connection();
  if (!connection) {
    throw new Error("Couldn't find a CDP connection");
  }
  const cUrl = new URL(connection.url());
  const cdpConnection = new ChromeProtocolPatched(cUrl.port, cUrl.hostname);
  if (!cUrl.pathname.startsWith("/devtools/browser")) {
    await cdpConnection._connectToSocket({
      webSocketDebuggerUrl: connection.url(),
      id: (await target.asPage()).mainFrame()._id
    });
    const { sessionId } = await cdpConnection.sendCommand(
      "Target.attachToTarget",
      void 0,
      { targetId: (await target.asPage()).mainFrame()._id, flatten: true }
    );
    cdpConnection.setSessionId(sessionId);
    return new Driver(cdpConnection);
  }
  const list = await cdpConnection._runJsonCommand("list");
  await cdpConnection._connectToSocket(list[0]);
  return new Driver(cdpConnection);
}

// src/gatherer/devtools.ts
var DevtoolsGatherer = class {
  _logs = [];
  onMessage(msgObj) {
    this._logs.push(msgObj);
  }
  /**
   * retrieve logs and clean cache
   */
  getLogs() {
    return this._logs.splice(0, this._logs.length);
  }
};

// src/auditor.ts
import Diagnostics from "lighthouse/lighthouse-core/audits/diagnostics.js";
import MainThreadWorkBreakdown from "lighthouse/lighthouse-core/audits/mainthread-work-breakdown.js";
import Metrics from "lighthouse/lighthouse-core/audits/metrics.js";
import ServerResponseTime from "lighthouse/lighthouse-core/audits/server-response-time.js";
import CumulativeLayoutShift from "lighthouse/lighthouse-core/audits/metrics/cumulative-layout-shift.js";
import FirstContentfulPaint from "lighthouse/lighthouse-core/audits/metrics/first-contentful-paint.js";
import LargestContentfulPaint from "lighthouse/lighthouse-core/audits/metrics/largest-contentful-paint.js";
import SpeedIndex from "lighthouse/lighthouse-core/audits/metrics/speed-index.js";
import InteractiveMetric from "lighthouse/lighthouse-core/audits/metrics/interactive.js";
import TotalBlockingTime from "lighthouse/lighthouse-core/audits/metrics/total-blocking-time.js";
import ReportScoring from "lighthouse/lighthouse-core/scoring.js";
import defaultConfig from "lighthouse/lighthouse-core/config/default-config.js";
import logger from "@wdio/logger";
var log = logger("@wdio/lighthouse-service:Auditor");
var Auditor = class {
  constructor(_traceLogs, _devtoolsLogs, _formFactor) {
    this._traceLogs = _traceLogs;
    this._devtoolsLogs = _devtoolsLogs;
    this._formFactor = _formFactor;
    if (_traceLogs) {
      this._url = _traceLogs.pageUrl;
    }
  }
  _url;
  _audit(AUDIT, params = {}) {
    const auditContext = {
      options: {
        ...AUDIT.defaultOptions
      },
      settings: {
        throttlingMethod: "devtools",
        formFactor: this._formFactor || DEFAULT_FORM_FACTOR
      },
      LighthouseRunWarnings: false,
      computedCache: /* @__PURE__ */ new Map()
    };
    try {
      return AUDIT.audit({
        traces: { defaultPass: this._traceLogs },
        devtoolsLogs: { defaultPass: this._devtoolsLogs },
        TestedAsMobileDevice: true,
        GatherContext: { gatherMode: "navigation" },
        ...params
      }, auditContext);
    } catch (error) {
      log.error(error);
      return {
        score: 0,
        error
      };
    }
  }
  /**
   * an Auditor instance is created for every trace so provide an updateCommands
   * function to receive the latest performance metrics with the browser instance
   */
  updateCommands(browser, customFn) {
    const commands = Object.getOwnPropertyNames(Object.getPrototypeOf(this)).filter(
      (fnName) => fnName !== "constructor" && fnName !== "updateCommands" && !fnName.startsWith("_")
    );
    commands.forEach((fnName) => browser.addCommand(fnName, customFn || this[fnName].bind(this)));
  }
  /**
   * Returns a list with a breakdown of all main thread task and their total duration
   */
  async getMainThreadWorkBreakdown() {
    const result = await this._audit(MainThreadWorkBreakdown);
    return result.details.items.map(
      ({ group, duration }) => ({ group, duration })
    );
  }
  /**
   * Get some useful diagnostics about the page load
   */
  async getDiagnostics() {
    const result = await this._audit(Diagnostics);
    if (!Object.prototype.hasOwnProperty.call(result, "details")) {
      return null;
    }
    return result.details.items[0];
  }
  /**
   * Get most common used performance metrics
   */
  async getMetrics() {
    const serverResponseTime = await this._audit(ServerResponseTime, { URL: this._url });
    const cumulativeLayoutShift = await this._audit(CumulativeLayoutShift);
    const result = await this._audit(Metrics);
    const metrics = result.details.items[0] || {};
    return {
      timeToFirstByte: Math.round(serverResponseTime.numericValue),
      serverResponseTime: Math.round(serverResponseTime.numericValue),
      domContentLoaded: metrics.observedDomContentLoaded,
      firstVisualChange: metrics.observedFirstVisualChange,
      firstPaint: metrics.observedFirstPaint,
      firstContentfulPaint: metrics.firstContentfulPaint,
      firstMeaningfulPaint: metrics.firstMeaningfulPaint,
      largestContentfulPaint: metrics.largestContentfulPaint,
      lastVisualChange: metrics.observedLastVisualChange,
      interactive: metrics.interactive,
      load: metrics.observedLoad,
      speedIndex: metrics.speedIndex,
      totalBlockingTime: metrics.totalBlockingTime,
      maxPotentialFID: metrics.maxPotentialFID,
      cumulativeLayoutShift: cumulativeLayoutShift.numericValue
    };
  }
  /**
   * Returns the Lighthouse Performance Score which is a weighted mean of the following metrics: firstMeaningfulPaint, interactive, speedIndex
   */
  async getPerformanceScore() {
    const auditResults = {
      "speed-index": await this._audit(SpeedIndex),
      "first-contentful-paint": await this._audit(FirstContentfulPaint),
      "largest-contentful-paint": await this._audit(LargestContentfulPaint),
      "cumulative-layout-shift": await this._audit(CumulativeLayoutShift),
      "total-blocking-time": await this._audit(TotalBlockingTime),
      interactive: await this._audit(InteractiveMetric)
    };
    if (!auditResults.interactive || !auditResults["cumulative-layout-shift"] || !auditResults["first-contentful-paint"] || !auditResults["largest-contentful-paint"] || !auditResults["speed-index"] || !auditResults["total-blocking-time"]) {
      log.info("One or multiple required metrics couldn't be found, setting performance score to: null");
      return null;
    }
    const scores = defaultConfig.categories.performance.auditRefs.filter((auditRef) => auditRef.weight).map((auditRef) => ({
      score: auditResults[auditRef.id].score,
      weight: auditRef.weight
    }));
    return ReportScoring.arithmeticMean(scores);
  }
  async _auditPWA(params, auditsToBeRun = Object.keys(PWA_AUDITS)) {
    const audits = await Promise.all(
      Object.entries(PWA_AUDITS).filter(([name]) => auditsToBeRun.includes(name)).map(
        async ([name, Audit]) => [name, await this._audit(Audit, params)]
      )
    );
    return {
      passed: !audits.find(([, result]) => result.score < 1),
      details: audits.reduce((details, [name, result]) => {
        details[name] = result;
        return details;
      }, {})
    };
  }
};

// src/gatherer/pwa.ts
import FRGatherer from "lighthouse/lighthouse-core/fraggle-rock/gather/session.js";
import pageFunctions from "lighthouse/lighthouse-core/lib/page-functions.js";
import NetworkRecorder from "lighthouse/lighthouse-core/lib/network-recorder.js";
import InstallabilityErrors from "lighthouse/lighthouse-core/gather/gatherers/installability-errors.js";
import WebAppManifest from "lighthouse/lighthouse-core/gather/gatherers/web-app-manifest.js";
import LinkElements from "lighthouse/lighthouse-core/gather/gatherers/link-elements.js";
import ViewportDimensions from "lighthouse/lighthouse-core/gather/gatherers/viewport-dimensions.js";
import serviceWorkers from "lighthouse/lighthouse-core/gather/driver/service-workers.js";

// src/scripts/collectMetaElements.ts
function collectMetaElements() {
  const selector = "head meta";
  const realMatchesFn = window.Element.prototype.matches;
  const metas = [];
  const _findAllElements = (nodes) => {
    for (let i = 0, el; el = nodes[i]; ++i) {
      if (!selector || realMatchesFn.call(el, selector)) {
        metas.push(el);
      }
      if (el.shadowRoot) {
        _findAllElements(el.shadowRoot.querySelectorAll("*"));
      }
    }
  };
  _findAllElements(document.querySelectorAll("*"));
  return metas.map((meta) => {
    const getAttribute = (name) => {
      const attr = meta.attributes.getNamedItem(name);
      if (!attr) {
        return;
      }
      return attr.value;
    };
    return {
      // @ts-ignore
      name: meta.name.toLowerCase(),
      // @ts-ignore
      content: meta.content,
      property: getAttribute("property"),
      // @ts-ignore
      httpEquiv: meta.httpEquiv ? meta.httpEquiv.toLowerCase() : void 0,
      charset: getAttribute("charset")
    };
  });
}

// src/gatherer/pwa.ts
var PWAGatherer = class {
  constructor(_session, _page, _driver) {
    this._session = _session;
    this._page = _page;
    this._driver = _driver;
    this._frGatherer = new FRGatherer(this._session);
    this._networkRecorder = new NetworkRecorder();
    NETWORK_RECORDER_EVENTS.forEach((method) => {
      this._session.on(method, (params) => this._networkRecorder.dispatch({ method, params }));
    });
    this._page.on("load", () => {
      this._networkRecords = this._networkRecorder.getRawRecords();
      delete this._networkRecorder;
      this._networkRecorder = new NetworkRecorder();
    });
  }
  _frGatherer;
  _networkRecorder;
  _networkRecords = [];
  async gatherData() {
    const pageUrl = await this._page?.url();
    const passContext = {
      url: pageUrl,
      driver: this._driver
    };
    const loadData = {
      networkRecords: this._networkRecords
    };
    const linkElements = new LinkElements();
    const viewportDimensions = new ViewportDimensions();
    const { registrations } = await serviceWorkers.getServiceWorkerRegistrations(this._frGatherer);
    const { versions } = await serviceWorkers.getServiceWorkerVersions(this._frGatherer);
    return {
      URL: { requestedUrl: pageUrl, finalUrl: pageUrl },
      WebAppManifest: await WebAppManifest.getWebAppManifest(this._frGatherer, pageUrl),
      InstallabilityErrors: await InstallabilityErrors.getInstallabilityErrors(this._frGatherer),
      MetaElements: await this._driver.evaluate(collectMetaElements, {
        args: [],
        useIsolation: true,
        deps: [pageFunctions.getElementsInDocument]
      }),
      ViewportDimensions: await viewportDimensions.afterPass(passContext),
      ServiceWorker: { versions, registrations },
      LinkElements: await linkElements.afterPass(passContext, loadData)
    };
  }
};

// src/gatherer/trace.ts
import { EventEmitter } from "node:events";
import NetworkRecorder2 from "lighthouse/lighthouse-core/lib/network-recorder.js";
import NetworkMonitor from "lighthouse/lighthouse-core/gather/driver/network-monitor.js";
import ProtocolSession from "lighthouse/lighthouse-core/fraggle-rock/gather/session.js";
import { waitForFullyLoaded } from "lighthouse/lighthouse-core/gather/driver/wait-for-condition.js";
import logger2 from "@wdio/logger";

// src/scripts/registerPerformanceObserverInPage.ts
function registerPerformanceObserverInPage() {
  window.____lastLongTask = window.performance.now();
  const observer = new window.PerformanceObserver((entryList) => {
    const entries = entryList.getEntries();
    for (const entry of entries) {
      if (entry.entryType === "longtask") {
        const taskEnd = entry.startTime + entry.duration;
        window.____lastLongTask = Math.max(window.____lastLongTask, taskEnd);
      }
    }
  });
  observer.observe({ entryTypes: ["longtask"] });
  window.____lhPerformanceObserver = observer;
}

// src/gatherer/trace.ts
var log2 = logger2("@wdio/lighthouse-service:TraceGatherer");
var TraceGatherer = class extends EventEmitter {
  constructor(_session, _page, _driver) {
    super();
    this._session = _session;
    this._page = _page;
    this._driver = _driver;
    NETWORK_RECORDER_EVENTS.forEach((method) => {
      this._networkListeners[method] = (params) => this._networkStatusMonitor.dispatch({ method, params });
    });
    this._protocolSession = new ProtocolSession(_session);
    this._networkMonitor = new NetworkMonitor(_session);
  }
  _failingFrameLoadIds = [];
  _pageLoadDetected = false;
  _networkListeners = {};
  _frameId;
  _loaderId;
  _pageUrl;
  _networkStatusMonitor;
  _networkMonitor;
  _protocolSession;
  _trace;
  _traceStart;
  _clickTraceTimeout;
  _waitConditionPromises = [];
  async startTracing(url) {
    delete this._trace;
    this._networkStatusMonitor = new NetworkRecorder2();
    NETWORK_RECORDER_EVENTS.forEach((method) => {
      this._session.on(method, this._networkListeners[method]);
    });
    this._traceStart = Date.now();
    log2.info(`Start tracing frame with url ${url}`);
    await this._driver.beginTrace();
    if (url === CLICK_TRANSITION) {
      log2.info("Start checking for page load for click");
      this._clickTraceTimeout = setTimeout(async () => {
        log2.info("No page load detected, canceling trace");
        return this.finishTracing();
      }, FRAME_LOAD_START_TIMEOUT);
    }
    await this._page.evaluateOnNewDocument(registerPerformanceObserverInPage);
    this._waitConditionPromises.push(
      waitForFullyLoaded(this._protocolSession, this._networkMonitor, { timedOut: 1 })
    );
  }
  /**
   * store frame id of frames that are being traced
   */
  async onFrameNavigated(msgObj) {
    if (!this.isTracing) {
      return;
    }
    if (this._failingFrameLoadIds.includes(msgObj.frame.url)) {
      this._waitConditionPromises = [];
      this._frameId = '"unsuccessful loaded frame"';
      this.finishTracing();
      this.emit("tracingError", new Error(`Page with url "${msgObj.frame.url}" failed to load`));
      if (this._clickTraceTimeout) {
        clearTimeout(this._clickTraceTimeout);
      }
    }
    if (
      // we already detected a frameId before
      this._frameId || // the event was thrown for a sub frame (e.g. iframe)
      msgObj.frame.parentId || // we don't support the url of given frame
      !isSupportedUrl(msgObj.frame.url)
    ) {
      log2.info(`Ignore navigated frame with url ${msgObj.frame.url}`);
      return;
    }
    this._frameId = msgObj.frame.id;
    this._loaderId = msgObj.frame.loaderId;
    this._pageUrl = msgObj.frame.url;
    log2.info(`Page load detected: ${this._pageUrl}, set frameId ${this._frameId}, set loaderId ${this._loaderId}`);
    if (this._clickTraceTimeout && !this._pageLoadDetected) {
      log2.info("Page load detected for click, clearing click trace timeout}");
      this._pageLoadDetected = true;
      clearTimeout(this._clickTraceTimeout);
    }
    this.emit("tracingStarted", msgObj.frame.id);
  }
  /**
   * once the page load event has fired, we can grab some performance
   * metrics and timing
   */
  async onLoadEventFired() {
    if (!this.isTracing) {
      return;
    }
    const loadPromise = Promise.all(this._waitConditionPromises).then(() => async () => {
      const minTraceTime = TRACING_TIMEOUT - (Date.now() - (this._traceStart || 0));
      if (minTraceTime > 0) {
        log2.info(`page load happen to quick, waiting ${minTraceTime}ms more`);
        await new Promise((resolve) => setTimeout(resolve, minTraceTime));
      }
      return this.completeTracing();
    });
    const cleanupFn = await Promise.race([
      loadPromise,
      this.waitForMaxTimeout()
    ]);
    this._waitConditionPromises = [];
    return cleanupFn();
  }
  onFrameLoadFail(request) {
    const frame = request.frame();
    if (frame) {
      this._failingFrameLoadIds.push(frame.url());
    }
  }
  get isTracing() {
    return typeof this._traceStart === "number";
  }
  /**
   * once tracing has finished capture trace logs into memory
   */
  async completeTracing() {
    const traceDuration = Date.now() - (this._traceStart || 0);
    log2.info(`Tracing completed after ${traceDuration}ms, capturing performance data for frame ${this._frameId}`);
    try {
      const traceEvents = await this._driver.endTrace();
      const startedInBrowserEvt = traceEvents.traceEvents.find((e) => e.name === "TracingStartedInBrowser");
      const mainFrame = startedInBrowserEvt && startedInBrowserEvt.args && startedInBrowserEvt.args.data.frames?.find((frame) => !frame.parent);
      if (mainFrame && mainFrame.processId) {
        const threadNameEvt = traceEvents.traceEvents.find((e) => e.ph === "R" && e.cat === "blink.user_timing" && e.name === "navigationStart" && e.args.data.isLoadingMainFrame);
        if (threadNameEvt) {
          log2.info(`Replace mainFrame process id ${mainFrame.processId} with actual thread process id ${threadNameEvt.pid}`);
          mainFrame.processId = threadNameEvt.pid;
        } else {
          log2.info(`Couldn't replace mainFrame process id ${mainFrame.processId} with actual thread process id`);
        }
      }
      this._trace = {
        ...traceEvents,
        frameId: this._frameId,
        loaderId: this._loaderId,
        pageUrl: this._pageUrl,
        traceStart: this._traceStart,
        traceEnd: Date.now()
      };
      this.emit("tracingComplete", this._trace);
      this.finishTracing();
    } catch (err) {
      log2.error(`Error capturing tracing logs: ${err.stack}`);
      this.emit("tracingError", err);
      return this.finishTracing();
    }
  }
  /**
   * clear tracing states and emit tracingFinished
   */
  finishTracing() {
    log2.info(`Tracing for ${this._frameId} completed`);
    this._pageLoadDetected = false;
    NETWORK_RECORDER_EVENTS.forEach(
      (method) => this._session.off(method, this._networkListeners[method])
    );
    delete this._networkStatusMonitor;
    delete this._traceStart;
    delete this._frameId;
    delete this._loaderId;
    delete this._pageUrl;
    this._failingFrameLoadIds = [];
    this._waitConditionPromises = [];
    this.emit("tracingFinished");
  }
  waitForMaxTimeout(maxWaitForLoadedMs = MAX_TRACE_WAIT_TIME) {
    return new Promise(
      (resolve) => setTimeout(resolve, maxWaitForLoadedMs)
    ).then(() => async () => {
      log2.error("Neither network nor CPU idle time could be detected within timeout, wrapping up tracing");
      return this.completeTracing();
    });
  }
};

// src/commands.ts
var log3 = logger3("@wdio/lighthouse-service:CommandHandler");
var TRACE_COMMANDS = ["click", "navigateTo", "url"];
function isCDPSessionOnMessageObject(data) {
  return data !== null && typeof data === "object" && Object.prototype.hasOwnProperty.call(data, "params") && Object.prototype.hasOwnProperty.call(data, "method");
}
var CommandHandler = class {
  constructor(_session, _page, _driver, _options, _browser) {
    this._session = _session;
    this._page = _page;
    this._driver = _driver;
    this._options = _options;
    this._browser = _browser;
    this._networkHandler = new NetworkHandler(_session);
    this._traceGatherer = new TraceGatherer(_session, _page, _driver);
    this._pwaGatherer = new PWAGatherer(_session, _page, _driver);
    _session.on("Page.loadEventFired", this._traceGatherer.onLoadEventFired.bind(this._traceGatherer));
    _session.on("Page.frameNavigated", this._traceGatherer.onFrameNavigated.bind(this._traceGatherer));
    _page.on("requestfailed", this._traceGatherer.onFrameLoadFail.bind(this._traceGatherer));
    this._pwaGatherer = new PWAGatherer(_session, _page, _driver);
    const commands = Object.getOwnPropertyNames(Object.getPrototypeOf(this)).filter(
      (fnName) => fnName !== "constructor" && !fnName.startsWith("_")
    );
    commands.forEach((fnName) => _browser.addCommand(
      fnName,
      this[fnName].bind(this)
    ));
    this._devtoolsGatherer = new DevtoolsGatherer();
    _session.on("*", this._propagateWSEvents.bind(this));
  }
  _isTracing = false;
  _networkHandler;
  _traceEvents;
  _shouldRunPerformanceAudits = false;
  _cacheEnabled;
  _cpuThrottling;
  _networkThrottling;
  _formFactor;
  _traceGatherer;
  _devtoolsGatherer;
  _pwaGatherer;
  /**
   * Start tracing the browser. You can optionally pass in custom tracing categories and the
   * sampling frequency.
   */
  startTracing({
    categories = DEFAULT_TRACING_CATEGORIES,
    path,
    screenshots = true
  } = {}) {
    if (this._isTracing) {
      throw new Error("browser is already being traced");
    }
    this._isTracing = true;
    this._traceEvents = void 0;
    return this._page.tracing.start({ categories, path, screenshots });
  }
  /**
   * Stop tracing the browser.
   */
  async endTracing() {
    if (!this._isTracing) {
      throw new Error("No tracing was initiated, call `browser.startTracing()` first");
    }
    try {
      const traceBuffer = await this._page.tracing.stop();
      if (!traceBuffer) {
        throw new Error("No tracebuffer captured");
      }
      this._traceEvents = JSON.parse(traceBuffer.toString());
      this._isTracing = false;
    } catch (err) {
      throw new Error(`Couldn't parse trace events: ${err.message}`);
    }
    return this._traceEvents;
  }
  /**
   * Returns the tracelogs that was captured within the tracing period.
   * You can use this command to store the trace logs on the file system to analyse the trace
   * via Chrome DevTools interface.
   */
  getTraceLogs() {
    return this._traceEvents;
  }
  /**
   * Returns page weight information of the last page load.
   */
  getPageWeight() {
    const requestTypes = Object.values(this._networkHandler.requestTypes).filter(Boolean);
    const pageWeight = sumByKey(requestTypes, "size");
    const transferred = sumByKey(requestTypes, "encoded");
    const requestCount = sumByKey(requestTypes, "count");
    return { pageWeight, transferred, requestCount, details: this._networkHandler.requestTypes };
  }
  /**
   * set flag to run performance audits for page transitions
   */
  enablePerformanceAudits({ networkThrottling, cpuThrottling, cacheEnabled, formFactor } = DEFAULT_THROTTLE_STATE) {
    if (!NETWORK_STATES[networkThrottling]) {
      throw new Error(`Network throttling profile "${networkThrottling}" is unknown, choose between ${Object.keys(NETWORK_STATES).join(", ")}`);
    }
    if (typeof cpuThrottling !== "number") {
      throw new Error(`CPU throttling rate needs to be typeof number but was "${typeof cpuThrottling}"`);
    }
    this._networkThrottling = networkThrottling;
    this._cpuThrottling = cpuThrottling;
    this._cacheEnabled = Boolean(cacheEnabled);
    this._formFactor = formFactor;
    this._shouldRunPerformanceAudits = true;
  }
  /**
   * custom command to disable performance audits
   */
  disablePerformanceAudits() {
    this._shouldRunPerformanceAudits = false;
  }
  /**
   * helper method to set throttling profile
   */
  async setThrottlingProfile(networkThrottling = DEFAULT_THROTTLE_STATE.networkThrottling, cpuThrottling = DEFAULT_THROTTLE_STATE.cpuThrottling, cacheEnabled = DEFAULT_THROTTLE_STATE.cacheEnabled) {
    if (!this._page || !this._session) {
      throw new Error("No page or session has been captured yet");
    }
    await this._page.setCacheEnabled(Boolean(cacheEnabled));
    await this._session.send("Emulation.setCPUThrottlingRate", { rate: cpuThrottling });
    await this._session.send("Network.emulateNetworkConditions", NETWORK_STATES[networkThrottling]);
  }
  async checkPWA(auditsToBeRun) {
    const auditor = new Auditor();
    const artifacts = await this._pwaGatherer.gatherData();
    return auditor._auditPWA(artifacts, auditsToBeRun);
  }
  _propagateWSEvents(data) {
    if (!isCDPSessionOnMessageObject(data)) {
      return;
    }
    this._devtoolsGatherer?.onMessage(data);
    const method = data.method || "event";
    try {
      log3.debug(`cdp event: ${method} with params ${JSON.stringify(data.params)}`);
    } catch {
    }
    if (this._browser) {
      this._browser.emit(method, data.params);
    }
  }
  async _initCommand() {
    await Promise.all(["Page", "Network", "Runtime"].map(
      (domain) => Promise.all([
        this._session?.send(`${domain}.enable`)
      ])
    ));
  }
  _beforeCmd(commandName, params) {
    const isCommandNavigation = ["url", "navigateTo"].some((cmdName) => cmdName === commandName);
    if (!this._shouldRunPerformanceAudits || !this._traceGatherer || this._traceGatherer.isTracing || !TRACE_COMMANDS.includes(commandName)) {
      return;
    }
    this.setThrottlingProfile(this._networkThrottling, this._cpuThrottling, this._cacheEnabled);
    const url = isCommandNavigation ? params[0] : CLICK_TRANSITION;
    return this._traceGatherer.startTracing(url);
  }
  _afterCmd(commandName) {
    if (!this._traceGatherer || !this._traceGatherer.isTracing || !TRACE_COMMANDS.includes(commandName)) {
      return;
    }
    this._traceGatherer.once("tracingComplete", (traceEvents) => {
      const auditor = new Auditor(traceEvents, this._devtoolsGatherer?.getLogs(), this._formFactor);
      auditor.updateCommands(this._browser);
    });
    this._traceGatherer.once("tracingError", (err) => {
      const auditor = new Auditor();
      auditor.updateCommands(
        this._browser,
        /* istanbul ignore next */
        () => {
          throw new Error(`Couldn't capture performance due to: ${err.message}`);
        }
      );
    });
    return new Promise((resolve) => {
      log3.info(`Wait until tracing for command ${commandName} finishes`);
      this._traceGatherer?.once("tracingFinished", async () => {
        log3.info("Disable throttling");
        await this.setThrottlingProfile("online", 0, true);
        log3.info("continuing with next WebDriver command");
        resolve();
      });
    });
  }
};

// src/index.ts
var DevToolsService = class {
  constructor(_options) {
    this._options = _options;
  }
  _command = [];
  _browser;
  async before(caps, specs, browser) {
    this._browser = browser;
    return await this._setupHandler();
  }
  async onReload() {
    if (!this._browser) {
      return;
    }
    return this._setupHandler();
  }
  async beforeCommand(commandName, params) {
    return Promise.all(this._command.map(async (c) => await c._beforeCmd(commandName, params)));
  }
  async afterCommand(commandName) {
    if (commandName === "switchToWindow") {
      await this._setupHandler();
    }
    return Promise.all(this._command.map(async (c) => await c._afterCmd(commandName)));
  }
  /**
   * set flag to run performance audits for page transitions
   */
  _enablePerformanceAudits({ networkThrottling, cpuThrottling, cacheEnabled, formFactor } = DEFAULT_THROTTLE_STATE) {
    if (!NETWORK_STATES[networkThrottling]) {
      throw new Error(`Network throttling profile "${networkThrottling}" is unknown, choose between ${Object.keys(NETWORK_STATES).join(", ")}`);
    }
    if (typeof cpuThrottling !== "number") {
      throw new Error(`CPU throttling rate needs to be typeof number but was "${typeof cpuThrottling}"`);
    }
    if (this._command.length === 1) {
      this._command[0].enablePerformanceAudits({ networkThrottling, cpuThrottling, cacheEnabled, formFactor });
    } else {
      for (const c of this._command) {
        c.enablePerformanceAudits({ networkThrottling, cpuThrottling, cacheEnabled, formFactor });
      }
    }
  }
  /**
   * custom command to disable performance audits
   */
  _disablePerformanceAudits() {
    if (this._command.length === 1) {
      this._command[0].disablePerformanceAudits();
    } else {
      for (const c of this._command) {
        c.disablePerformanceAudits();
      }
    }
  }
  async _setThrottlingProfile(networkThrottling = DEFAULT_THROTTLE_STATE.networkThrottling, cpuThrottling = DEFAULT_THROTTLE_STATE.cpuThrottling, cacheEnabled = DEFAULT_THROTTLE_STATE.cacheEnabled) {
    if (this._command.length === 1) {
      this._command[0].setThrottlingProfile(networkThrottling, cpuThrottling, cacheEnabled);
    } else {
      for (const c of this._command) {
        c.setThrottlingProfile(networkThrottling, cpuThrottling, cacheEnabled);
      }
    }
  }
  async _checkPWA(auditsToBeRun) {
    if (this._command.length === 1) {
      return await this._command[0].checkPWA(auditsToBeRun);
    }
    return Promise.all(this._command.map(async (c) => await c.checkPWA(auditsToBeRun)));
  }
  async _setupHandler() {
    if (!this._browser) {
      return;
    }
    this._command.length = 0;
    const browsers = Object.keys(this._browser).includes("sessionId") ? [this._browser] : this._browser.instances.map((i) => this._browser.getInstance(i));
    for (const browser of browsers) {
      const puppeteer = await browser.getPuppeteer().catch(() => void 0);
      if (!puppeteer) {
        return setUnsupportedCommand(browser);
      }
      const url = await browser.getUrl();
      const target = url !== "data:," ? await puppeteer.waitForTarget(
        /* istanbul ignore next */
        (t) => t.url().includes(url)
      ) : await puppeteer.waitForTarget(
        /* istanbul ignore next */
        // @ts-expect-error
        (t) => t.type() === "page" || Boolean(t._getTargetInfo().browserContextId)
      );
      if (!target) {
        throw new Error("No page target found");
      }
      const page = await target.page() || null;
      if (!page) {
        throw new Error("No page found");
      }
      const session = await target.createCDPSession();
      const driver = await getLighthouseDriver(session, target);
      const cmd = new CommandHandler(session, page, driver, this._options, browser);
      await cmd._initCommand();
      this._command.push(cmd);
    }
    this._browser.addCommand("enablePerformanceAudits", this._enablePerformanceAudits.bind(this));
    this._browser.addCommand("disablePerformanceAudits", this._disablePerformanceAudits.bind(this));
    this._browser.addCommand("checkPWA", this._checkPWA.bind(this));
  }
};
export {
  DevToolsService as default
};
